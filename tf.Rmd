---
title: "Cómo hacer un TFG/TFM en informática"
author: "JJ Merelo"
date: "1/9/2020"
output: html_document
bibliography: TF.bib
---

# Motivación

Tanto en los tribunales de trabajos fin de grado o máster (TFG/TFM, a partir de ahora sólo TF) en los que he participado me encuentro repitiendo, una y otra vez, las mismas reglas sobre lo que son o no son tanto los trabajos en sí, como la tutorización, como las presentaciones. El trasfondo es que, realmente, parece que nadie tiene claro lo que es o lo que debe de ser. En la mayor parte de los casos es irrelevante: los tribunales son soberanos, y la nota que va a obtener tiene poca relación no sólo con el trabajo realizado o su calidad, sino también con TFs de similar nivel corregidos en otros tribunales.

En todo caso, la nota obtenida es, en la mayor parte de los casos, irrelevante. Un TF es una asignatura, y cómo tal debería servir para que el estudiante aprenda; si, como debería ser, el trabajo es liberado [@porqueliberar], es un muestrario de las técnicas y habilidades que el estudiante ha sido capaz de desarrollar a lo largo del grado.

> Dejemos de lado si ha sido capaz de desarrollarlas *en* él o *a pesar de* o *aparte de* él. Si es muestrario de habilidades, de dónde procedan esas habilidades es totalmente secundario.

Por eso voy a tratar de dar una serie de reglas para poder aprovechar, efectivamente, 
este grado para crecer en la ingeniería que se ha elegido y convertirse en mejor profesional. Dirigido principalmente al estudiante, pero también a quién le toque ser tutor o tutora de este tipo de trabajos.

En todo esto, soy totalmente consciente de que, en la mayor parte de los casos, un TF es un trámite molesto que necesitas para poder acceder a un grado que necesitas, sobre todo, por el título que conlleva, no por los conocimientos que te impartan. Muchos estudiantes están ya trabajando a tiempo parcial o completo y sin el grado simplemente no pueden acceder a los convenios laborales o puestos mejor remunerados. El TF lo tienen que compatibilizar con este trabajo y lo que se desea es quitárselo de enmedio lo antes posible, sin que represente una gran cantidad de trabajo.

Por eso, lo que voy a contar trata de *no* aportar carga de trabajo adicional; en muchos casos incluso puede ayudar a tener el trabajo más enfocado y dirigido desde el principio, y a permitir organizarse el trabajo mejor para trabajar con regularidad y llegar al final más rápidamente y, sobre todo, con más eficiencia en las horas invertidas y también en el retorno de la inversión de esas horas. En todo caso, no es absolutista y no representa un camino zen de perfección: toma las reglas que te convengan o te parezcan más razonables, y deja el resto.

Este trabajo, además, es libre y está en un repositorio. Cópialo y adáptalo para entregarlo a tus tutorizados, o si crees que hay algún error o quieres aportar algo a esta copia, hazlo también. Encantado revisaré el PR y lo añadiré a la versión publicada, que actualizaré a continuación.

Como cualquier TF, debemos empezar por el 

## estado del arte

No he encontrado demasiadas guías prácticas sobre cómo afrontar el TF. Hay trabajos, como [@rodriguez2012como], que hacen una panorámica de qué tipo de trabajos recogen los reglamentos de TFG de diferentes universidades. El libro de García Sanz y Martínez Clares [@sanz2012guia] promete ser una guía práctica, pero es quizás demasiado genérico (y extenso) para poder usarse de forma práctica; no está mal, sin embargo, consultarlo antes de ponerse a trabajar. Alier et al. [@alier2012preguntas] proponen una estructuración del trabajo en tres hitos (lo que es un poco escaso para trabajos informáticos) y una serie de preguntas para cada uno de ellos, del estilo de "¿Existe una planificación del trabajo a realizar?". Puede ayudar sobre todo al tutor, pero desde luego no ayuda al estudiante a hacer dicha planificación o cómo enfocarla. Por último, la guía práctica de Monferrer y otros [@monferrer2012trabajo] puede ayudar a centrar el desarrollo inicial de un trabajo, pero es un poco demasiado genérica para ser de ayuda a estudiantes de informática. 

El problema, muchas veces, es que el estudiante realmente no tiene conocimientos (porque su grado no se ha molestado en impartírselo) para *tener* un proyecto y llevarlo a cabo. Así que vamos al principio, qué es un proyecto y cómo plantearlo.

## Un TF es la solución a un problema usando medios informáticos.

Es decir, en un TF, sea de "investigación" o de cualquier otro tipo (dejemos de lado los llamados "de revisión", que en general son para salir del paso y reflejan muy poco las habilidades adquiridas por el estudiante en una ingeniería), tienes que resolver un problema. El problema debe ser tan real como sea posible, y debe expresarse en términos cuantitativos si lo admite. Por ejemplo

* Saber qué personas con dispositivos móviles pasan por un lugar determinado, o por varios lugares, y qué tiempo pasan ahí.

Ese problema puede plantearse en varios contextos; por ejemplo, saber si vuelven y cuanto vuelven o contar cuantas personas hay, por temas de aforo (relacionado con el COVID19 o cualquier otra razón). En ese sentido, volvemos a hacer énfasis en que deben ser problemas *reales*, al menos lo más reales posibles. Sería bastante fatuo decir que se va a resolver el problema del COVID, sin embargo un subproblema sí se puede resolver, y por medios informáticos.

En este sentido, *no* sería un problema lo siguiente

* Construir un dispositivo que capte MACs de Bluetooth y WiFi.

Y no lo es principalmente porque no dice qué problema va a resolver. 

Saber qué problema se va a resolver es esencial. Del problema surge la motivación, pero también los casos de uso, es decir, las diferentes situaciones en las que diferentes tipos de usuarios interaccionarán con la solución propuesta para resolver, en ese caso, su problema. En el primer caso, las posibles aplicaciones o el problema que uno tenga en mente serán casos de uso, y de esa forma se tendrán que crear, adicionalmente, lógica de negocio para presentar esa información, o para almacenarla y procesarla. En el segundo caso no hay casos de uso. Se construye el dispositivo. Capta las MACs. Ya está. ¿Dónde se guardan esas MAC? ¿Se tienen que guardar o no?

En esto de puede ayudar la técnica del Design Thinking [@steinbeck2011design]. Recuerda que siempre es mejor, y va a ser para ti más interesante, que resuelvas *tu* problema que el que te lleguen con una solución ya hecha que ni siquiera se te haya ocurrido a ti. A partir de aquí, ya puedes pasar a la siguiente fase.

## Objetivos de un TF

Un TFG tiene que culminar en una memoria, que rara vez se lee alguien, pero que tiene que estar ahí; sobre todo si lo has liberado (recuerda, *debes* liberarlo) va a quedar como una parte aprovechable que permitirá, a quien continúe o use ese proyecto, entender por qué ha llegado a ese estado y qué se puede hacer para que evolucione o se adapte a un contexto determinado.

La memoria suele empezar con los objetivos; no siempre es así, pero así debería ser. El primer capítulo debe empezar por la motivación ("Se necesita un sistema de medición automática del aforo y de la duración de la estancia de una persona en un recinto cerrado"), pero a continuación, se deben experesar cuales son los objetivos del trabajo, es decir, qué parte de ese problema vamos a dejar resuelta y cuál se va a dejar como trabajo futuro.

Un sistema tal como ese puede tener muchos componentes. Por ejemplo, puede que sea un sólo local en cuyo caso la solución será relativamente fácil. Pero puede ser un local con muchas estancias; o pueden ser muchos locales separados físicamente. Los objetivos deben estar claros, porque de los objetivos saldrán los casos de uso (una vez más, los casos de uso son muy importantes) y de los casos de uso los hitos y tareas para resolverlos. Por ejemplo, puede ser el siguiente objetivo

* Crear un sistema que se pueda conectar a un sistema informático existente y que sea capaz de contar el número total de personas en un local así como tiempo de permanencia, con el sistema costando menos de 30€ en total.

Los objetivos deben ser alcanzables, y en lo posible cuantitativos. En este caso, nos hemos comprometido a que valga menos de 30€ (lo que puede excluir, por ejemplo, equipos del tipo Raspi). Pero en subobjetivos se puede ir más allá. 

* Subobjetivos
    * Debe ser capaz de contar en recintos de x metros cuadrados.
    * Debe contar el número de personas con una resolución de 5 minutos.

En el primer caso, va a ser totalmente diferente la solución dependiendo de la dimensión del recinto; el segundo nos va a dar un límite en la capacidad de procesamiento del sistema. Que en este caso es amplia, pero puede ser de 1 segundo, en cuyo caso habrá que componérselas. 

**No** será un objetivo
* Construir un dispositivo basado en una raspberry pi que capte WiFi y Bluetooth

Por varias razones. Un objetivo siempre tiene que estar en el dominio del problema, o en un contexto de negocio. Si el problema, por ejemplo, es automatizar los procesos de desarrollo de una empresa que provee soluciones de gestión de contenidos, un objetivo podrá ser "Crear configuraciones repetibles que funcionen con una sola orden" o "reducir el tiempo de despliegue de desarrollo a 5 minutos" o "Poder adaptar soluciones existentes a una nueva solución con una semana-persona". El objetivo **no será nunca**

* Desarrollar un script de ansible que instale todas las aplicaciones que usamos ahora.

Un objetivo *nunca* debe incluir una solución al problema si se alcanza el mismo; es algo que se debe de alcanzar, y justificar, durante el desarrollo de un proyecto. Y nunca debe ser una tarea cerrada. Un TF siempre debe resolver un problema (o parte del mismo), no hacer una tarea.

Los objetivos del proyecto son uno de los apartados más importantes del mismo; en otro artículo [@objetivos] describo cómo formularlos correctamente y qué hace que sean buenos o malos.

## El TF y la memoria

Un TF es un trabajo, claro, pero se evalúa mediante una memoria, que debemos asumir que van a leer, porque aunque es muy probable que no se lea completa, sí pueden leer (o tratar de leer) precisametne la parte que está mal escrita o la que falta; el tutor sí debe leerse al menos una parte considerable, o la estructura de la misma.

> Ojo: no se debe pretender, en general, que el tutor sela lea y corrija los puntos y comas, y menos si se presenta completa unos días antes de la presentación. En general, el tutor establecerá líneas generales u objectivos que la memoria debe cumplir (no tener faltas de ortografía, por ejemplo); quien la escriba debe asegurarse de que se cumplen.

Trabajo y memoria deben de ir unidos, en general. No suele suceder así, y esto es un error, pero lo mejor es que se considere la memoria como documentación del trabajo hecho para el TF y parte integral del mismo, no algo que hay que escribir al final para entregarlo y quitarse el tema de encima. Por eso es muy conveniente (d)escribir el trabajo según se vaya haciendo. Porque además, esas fases del trabajo corresponderán también a las diferentes secciones de una memoria.

### Introducción

En este capítulo debe ponerse la motivación, los objetivos generales, los subobjetivos, y describirse claramente el problema que se trata de resolver y todo lo que contribuya a entender el contexto. Si es parte del trabajo en la empresa, esto es lo que se debe describir, si está ya funcionando, también, si es un trabajo de investigación, por qué se ha elegido hacer ese trabajo específico de investigación. También se explicará el resto de la memoria, su estructura, e info adicional: en qué repositorio está, por ejemplo, o si los datos del trabajo se han publicado en algún lugar.

### Requisitos funcionales

En un capítulo tendrán que ir todos los casos de uso. En general, todo las restricciones que hay (por el negocio al que se aplique, por ejemplo) y por supuesto los casos de uso, qué es lo que queremos que el sistema resuelva. Por supuesto, estos casos de uso tendrán que estar relacionados con los objetivos; por eso es conveniente escribir a la vez que se trabaja: podemos encontrarnos que los casos de uso van más allá (en cuyo caso habrá que modificarlos) y o más acá (en cuyo caso, también, claro). Lo más importante es que cada capítulo forma parte de una misma narrativa, y los RFs no pueden estar "en el aire", sin tener ningún tipo de relación con los objetivos. Estos casos de uso deben referirse explícitamente a los objetivos, y de hecho tienen que ser anteriores a los mismos, por lo que dentro de ellos tendrá que explicarse claramente por qué. Y la motivación puede ser implícita o explícita: un caso de uso puede haber generado un objetivo.

### Metodología

Una vez que sepas, aunque sea inicialmente, qué vas a hacer, necesitas ponerte, efectivamente, a hacerlo. Puede que no tengas todos los requisitos al principio, pero al menos tendrás los primeros o sabrás por dónde tienes que empezar. Hoy en día la mayoría de los proyectos usan metodologías ágiles basadas en SCRUM. Te pillas una historia de usuario, y la conviertes en una serie de hitos (o *milestones*) que hay que ir alcanzando antes de tener la historia de usuario completa. Por ejemplo, vamos al proyecto anterior. Una historia de usuario puede ser algo como "El usuario debe de recibir información sobre las personas que hay en el recinto de su interés".

> La historia de usuario es expresamente vaga. Si dices "voy a crear una página web que tenga el número de personas en el recinto" excluyes muchas formas posibles de interacción, desde un bot de Telegram (al que se le pregunte) hasta enviarlo a una cuenta de Twitter. Por eso los objetivos no deben ser nunca el producto que vas a desarrollar; es algo que tiene que decidirse en función de los requisitos funcionales (y de otro tipo)

De ahí saldrán un montón de productos intermedios. Pero en la parte más bajas de los mismos tendrá que estar el hito de "Captar los paquetes BT y almacenarlos transitoriamente en una estructura de datos". Ese puede ser el hito inicial. Un hito tiene que describir un producto concreto, un producto mínimamente viable sobre el que se pueda construir. En este caso, una clase o módulo que se conecte con el hardware (que se habrá decidido o elegido en otro hito) y tenga un API del que se pueda obtener ese resultado.

> Sobre esto, un proyecto va a ser siempre construir una serie de capas de abstracción. El diseño de una aplicación es algo a lo que no se presta suficiente atención, ni yo voy a hacerlo aquí. Pero no es algo directo, y merece la pena que se pare uno un poco a la hora de hacerlo.

En cualquier caso, hay que hacer un *sprint* para llevar a cabo el hito, y durante el mismo, tomar una serie de decisiones sobre el diseño, bibliotecas externas que se van a usar, etcétera. Todo debe ir bien anotado (los mensajes de commit pueden servir para eso), porque nos va a servir en el siguiente capítulo.

Por otro lado, es imprescindible que uses git para desarrollar el proyecto; por un lado, porque es lo que se usa en la empresa, por otro lado, porque te permitirá documentat en línea el código, y referirte a issues y demás. Y porque GitHub o GitLab son verdaderos sitios de trabajo en grupo, donde puedes (si el tutor/a quiere) interaccionar con el resto de las personas implicadas; puedes solicitar reviews de lo|as tutore|as o ellos te pueden poner issues para que corrijas algún aspecto del mismo. Estos issues pueden estar fuera de un hito, pero tú puedes añadirlos al mismo (o crear uno que sea producto final o algo así). El hecho de que esté en un issue te permitirá controlar más fácilmente la interacción y consecución del mismo.

En la metodología tendrás que incluir (porque se evalúa) como se ha hecho el control de calidad del producto. En general, debes usar tests desde abajo (funcionales) hasta arriba (integración, y todos los issues se deben cerrar con un test que permita asegurarse de que ese issue no va a volver a aparecer; una vez terminado código + tests se cierra el issue desde un commit.

> Lo que no quiere decir que se use un sólo commit para todo un issue. Puede haber uno o muchos; en el mensaje de commit se puede aclarar cómo se avanza para cerrar ese issue.

Todo el proyecto debe estar bien engarzado: los requisitos deben aparecer en milestones, los issues deben estar bien enmarcados y avanzar un hito concreto, y cada vez que se cierre un hito se puede hacer un release. Pero con todo esto podrás avanzar fácilmente tanto en el proyecto como en la memoria, que al fin y al cabo es la descripción de lo que has hecho en el mismo.

> Habría que dedicar otro artículo completo a issues y commits. Pero basten un par de reglas: los issues deben ser descriptivos del problema que se quiere resolver específicamente con los mismos, o cómo se va a avanzar hacia el hito. Los commits son los que deben decir qué se ha hecho. Todo commit debe referirse a un issue (puede haber (pocas) excepciones), y un issue *siempre* se tiene que cerrar con un commit.

### Estado del arte y diseño

En los trabajos científicos, el estado del arte es una parte esencial e independiente. Se trata de saber cómo está el panorama en el problema que se trate de resolver. Por ejemplo, en el caso que nos ocupa, tendremos un montón de placas, conocidas o no, con HATs o lo que sea que pueden ser capaces de captar tramas de Bluetooth o WiFi. Cada una de ellas tendrá sus méritos y sus deméritos.

Pero esta sección de la memoria no es para que se muestre que has sido capaz de buscar por internet y copiar con más o menos fortuna una hoja de especificaciones, muchas de las cuales pueden venir, o no, a cuento. Se trata de que conoces las opciones que tienes a la hora de resolver un problema y que has escogido la mejor dados tus requisitos.

Por ejemplo, **no** debes hacer esto

* Capítulo que se llame "nanoordenadores y accesorios de los mismos", con imágenes (sin atribuirlas correctamente) y tablas diversas. A continuación, en Diseño "He escogido una Raspi porque tenía una que me tocó en un barril de Ariel". 

No. Se trata de que ya sabes cuales son tus requisitos, de los cuales hemos resaltado el coste (pero podía ser también velocidad de procesamiento). *Teniendo en cuenta* tus requisitos, puedes hacer una tabla (o contarlo) de todo lo que hay en el *estado del arte* que lo cumpla. Y finalmente, en el *diseño*, optas por el que te dé mejores prestaciones en algún aspecto que *tienes también que haber decidido de antemano*.

Y el estado del arte (y diseño) se debe extender a todo, tanto lo que esté en el proyecto como lo que hayas usado; en algunas cosas te lo puedes saltar (por ejemplo, el editor), pero en general, que muestres conocimiento de herramientas de desarrollo, de implementación y de despliegue es lo que se busca en un TF.



## References